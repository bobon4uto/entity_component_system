#define VUPS_IMPLEMENTATION
#include "../vups.h"

u meta_macro_count_args (String_Holder in, u position) {
  char c = in.items[position];
  u count = 1;
  while (c!=';') {
    if (position >= in.count) {
      return 0;
    }
    c = in.items[++position];
    if (c==',') ++count;
  }
  return count;
}
u meta_macro_count_args_for_each(String_Holder in, const char* target_function) {
  // lets count maximum args and make counter macro
  u count = 0;
  u target_function_len = strlen(target_function);

  for ( u i = 0;i<in.count;++i) {
  //  printf("comparing: (%*s == %s)", (i32)target_function_len, in.items + i, target_function);
    if (strncmp(in.items + i, target_function, target_function_len)) {
      u cur_count = meta_macro_count_args (in, i);
      if (cur_count == 0) break;
      if (cur_count > count) count=cur_count;
    }
  }
  return count;
}
String_Holder make_meta_macro_function_infinitely_variadic(u count_needed,const char* function_name) {
  String_Holder sh0 = {0};
  String_Holder* sh = &sh0;
  sh_appendf(sh, "// DISCLAIMER: this file is generated by " __FILE__ ":" "%d" "\n", __LINE__);
      sh_appendf(sh, "#ifndef MACROBEGIN\n");
      sh_appendf(sh, "#define MACROBEGIN\n");
      sh_appendf(sh, "#endif // MACROBEGIN\n");
      sh_appendf(sh, "#ifndef MACROEND\n");
      sh_appendf(sh, "#define MACROEND\n");
      sh_appendf(sh, "#endif // MACROEND\n");
  for (u i = 1; i<=count_needed; ++i) {
    sh_appendf(sh, "#define %s%zu(", function_name, i);
    for (u j=1; j<=i; ++j){
      sh_appendf(sh, "arg%zu,", j);
    }
    sh->count--;
    sh_appendf(sh, ") ");
      sh_appendf(sh, "MACROBEGIN");
    for (u j=1; j<=i; ++j){
      sh_appendf(sh, " MACROFUNC(arg%zu)", j);
    }
      sh_appendf(sh, " MACROEND\n");
  }


    sh_appendf(sh, "#define %s(...) _%s_COUNT(__VA_ARGS__", function_name, function_name);
  for (u i = count_needed; i>=1; --i) {
    sh_appendf(sh, ", %s%d", function_name, i);
  }
    sh_appendf(sh, ")(__VA_ARGS__)\n");
    sh_appendf(sh, "#define _%s_COUNT(", function_name);
  for (u i = 1; i<=count_needed; ++i) {
    sh_appendf(sh, "arg%d, ", i);
  }
    sh_appendf(sh, "macro, ...) macro\n");



    //sh_appendf(sh, "#undef MACROBEGIN\n");
    //sh_appendf(sh, "#undef CALL_FUNCTION\n");
    //sh_appendf(sh, "#undef MACROEND\n");
    sh_appendf(sh, "\n");


  return sh0;
}

int main(int argc, char **argv) {
  char* in_file_path = "main.mm.c";
  char* out_file_path = "a.out";
  char* function_name = "function";
  bool do_print = false;
  if (argc < 2) {
    printf("usage: %s [-o output] [-p]{print to stdout} [-f function_name] file", argv[0]);
    exit(0);
  }
  else {
    for (i32 i = 1; i < argc; ++i) {
      if (argv[i][0]=='-') {
          switch (argv[i][1]) {
            case 'o': out_file_path = argv[++i]; break;
            case 'f': function_name = argv[++i]; break;
            case 'p': do_print = true; break;
            //case '\0': break;
          }
      }
      else in_file_path = argv[i];
    }
    printf("in_file_path = %s\n", in_file_path);
    printf("out_file_path = %s\n", out_file_path);
    printf("function_name = %s\n", function_name);
  }
  String_Holder in0 = {0};
  String_Holder* in = &in0;
  read_file(in, in_file_path);
  //printf ("%s",sh_c_str(in));
  u count_needed = meta_macro_count_args_for_each(in0,function_name);
  printf("count = %zu\n", count_needed);
  String_Holder out0 = make_meta_macro_function_infinitely_variadic(count_needed, function_name);
  String_Holder* out = &out0;


  if (out_file_path) {
    write_file(out,out_file_path);
  }
  if (do_print) {
    printf("%s", sh_c_str(out));
  }

  sh_free(in);
  sh_free(out);
  return 0;

}
